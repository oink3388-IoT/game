<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>經典街機 - 太空侵略者 (Space Invaders)</title>
  <style>
    body {
      margin: 0;
      background: linear-gradient(to bottom, #000033, #000000);
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: 'Courier New', monospace;
      color: #00ff00;
      overflow: hidden;
    }
    #game-container {
      position: relative;
      border: 4px solid #00ff00;
      box-shadow: 0 0 30px #00ff00;
    }
    canvas {
      image-rendering: pixelated;
      background: #000011;
      display: block;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 20px;
      text-shadow: 0 0 10px #00ff00;
    }
    #high-score {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 20px;
      text-shadow: 0 0 10px #ff0000;
    }
    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: #ffff00;
      text-shadow: 0 0 20px #ff0000;
      pointer-events: none;
      display: none;
      animation: blink 0.8s infinite;
    }
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.2; }
    }
    #instructions {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      color: #00ff00;
      text-align: center;
      text-shadow: 0 0 5px #00ff00;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="ui">
      <div>分數: <span id="score">0</span></div>
      <div>關卡: <span id="level">1</span></div>
      <div>生命: <span id="lives">3</span></div>
    </div>
    <div id="high-score">最高分: <span id="highscore">0</span></div>
    <canvas id="canvas" width="500" height="700"></canvas>
    <div id="message">GAME OVER</div>
    <div id="instructions">
      ← → 移動 | 空白鍵射擊 | P 暫停 | 點擊螢幕重新開始
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;

    // UI 元素
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const livesEl = document.getElementById('lives');
    const highscoreEl = document.getElementById('highscore');
    const message = document.getElementById('message');

    // 遊戲狀態
    let gameState = 'menu'; // menu, playing, paused, gameover
    let score = 0;
    let highScore = localStorage.getItem('spaceInvadersHighScore') || 0;
    highscoreEl.textContent = highScore;
    let level = 1;
    let lives = 3;
    let keys = {};
    let lastShootTime = 0;
    const SHOOT_COOLDOWN = 200; // ms
    let paused = false;

    // 音效 (Web Audio API - 復古 beep)
    let audioCtx;
    function initAudio() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    function playSound(freqs, duration, type = 'square') {
      if (!audioCtx) return;
      try {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type;
        o.frequency.setValueAtTime(freqs[0] || 440, audioCtx.currentTime);
        if (freqs.length > 1) {
          o.frequency.exponentialRampToValueAtTime(freqs[1], audioCtx.currentTime + duration / 2);
        }
        g.gain.setValueAtTime(0.15, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        o.connect(g);
        g.connect(audioCtx.destination);
        o.start(audioCtx.currentTime);
        o.stop(audioCtx.currentTime + duration);
      } catch(e) {}
    }
    const sounds = {
      shoot: () => playSound([800, 600], 0.1),
      invadeKill: () => playSound([200, 100], 0.2, 'sawtooth'),
      barrierHit: () => playSound([300], 0.05),
      playerHit: () => playSound([100, 50], 0.4, 'sawtooth'),
      levelUp: () => playSound([440, 554, 659], 0.6, 'sine'),
      ufo: () => playSound([300, 400, 300, 500], 0.3)
    };

    // 玩家
    const player = {
      x: WIDTH / 2 - 20,
      y: HEIGHT - 80,
      width: 40,
      height: 24,
      speed: 5,
      invincible: 0 // 閃爍無敵時間
    };

    // 子彈陣列
    const playerBullets = [];
    const PLAYER_BULLET_SPEED = 12;
    const enemyBullets = [];
    const ENEMY_BULLET_SPEED = 3;

    // 敵人侵略者
    const invaders = [];
    let invaderMoveX = 1;
    let invaderSpeed = 0.5;
    let dropDistance = 20;
    let frameCount = 0;
    const MOVE_FRAMES = 30; // 每多少幀移動一次

    // 屏障 (4個可破壞牆，每個32x32格子組成)
    const barriers = [];
    const BARRIER_ROWS = 8;
    const BARRIER_COLS = 12;
    const BARRIER_WIDTH = 60;
    const BARRIER_HEIGHT = 50;
    const BARRIER_X = [50, 150, 300, 400]; // 4個位置
    const BRICK_WIDTH = 5;
    const BRICK_HEIGHT = 5;

    // UFO (Bonus)
    let ufo = null;
    let ufoTimer = 0;

    // 初始化屏障
    function createBarriers() {
      barriers.length = 0;
      BARRIER_X.forEach((bx, i) => {
        const barrier = [];
        for (let row = 0; row < BARRIER_ROWS; row++) {
          barrier[row] = [];
          for (let col = 0; col < BARRIER_COLS; col++) {
            barrier[row][col] = 1; // 完整磚
          }
        }
        barriers.push({ x: bx, y: HEIGHT - 200, bricks: barrier });
      });
    }

    // 繪製玩家 (經典太空船)
    function drawPlayer(ctx, x, y, invincible = false) {
      if (invincible > 0 && Math.floor(frameCount / 5) % 2) return; // 閃爍
      ctx.save();
      ctx.translate(x + 20, y + 12);
      // 船身
      ctx.fillStyle = '#00ffff';
      ctx.fillRect(-18, -10, 36, 20);
      // 翼
      ctx.fillStyle = '#0088ff';
      ctx.fillRect(-18, -5, 12, 10);
      ctx.fillRect(6, -5, 12, 10);
      // 駕駛艙
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(-6, -8, 12, 6);
      // 炮口
      ctx.fillStyle = '#ff0000';
      ctx.fillRect(-2, 10, 4, 8);
      ctx.restore();
    }

    // 繪製侵略者 (3種類型，像原版)
    function drawInvader(ctx, x, y, type) {
      ctx.save();
      ctx.translate(x + 16, y + 16);
      let color, details;
      switch(type) {
        case 0: // 上排: 大螃蟹 (紅)
          color = '#ff0000';
          ctx.fillStyle = color;
          ctx.fillRect(-12, -8, 24, 16); // 身
          ctx.fillRect(-16, 0, 8, 8); // 左鉗
          ctx.fillRect(8, 0, 8, 8); // 右鉗
          ctx.fillStyle = '#cc0000';
          ctx.fillRect(-10, -12, 20, 4); // 頂
          break;
        case 1: // 中排: 章魚 (綠/粉)
          color = type === 1 ? '#00ff00' : '#ff00ff';
          ctx.fillStyle = color;
          ctx.fillRect(-10, -6, 20, 12); // 身
          ctx.fillStyle = '#006600';
          ctx.fillRect(-14, 2, 28, 6); // 底腳
          ctx.fillRect(-12, -10, 4, 4);
          ctx.fillRect(8, -10, 4, 4);
          break;
        case 2: // 下排: 小蝦 (白)
          color = '#ffffff';
          ctx.fillStyle = color;
          ctx.fillRect(-8, -4, 16, 8); // 身
          ctx.fillRect(-12, 0, 6, 6); // 尾
          ctx.fillRect(6, 0, 6, 6);
          break;
      }
      // 眼睛
      ctx.fillStyle = '#000000';
      ctx.fillRect(-6, -6, 4, 4);
      ctx.fillRect(2, -6, 4, 4);
      ctx.restore();
    }

    // 繪製子彈
    function drawBullet(ctx, x, y, color = '#ffff00') {
      ctx.fillStyle = color;
      ctx.fillRect(x - 1, y - 6, 2, 12);
    }

    // 繪製屏障磚
    function drawBarrier(ctx, barrier) {
      ctx.fillStyle = '#00ff88';
      for (let row = 0; row < BARRIER_ROWS; row++) {
        for (let col = 0; col < BARRIER_COLS; col++) {
          if (barrier.bricks[row][col]) {
            const bx = barrier.x + col * BRICK_WIDTH;
            const by = barrier.y + row * BRICK_HEIGHT;
            ctx.fillRect(bx, by, BRICK_WIDTH, BRICK_HEIGHT);
          }
        }
      }
    }

    // 繪製UFO
    function drawUFO(ctx, x, y) {
      ctx.save();
      ctx.translate(x + 24, y + 12);
      ctx.fillStyle = '#00ffff';
      ctx.fillRect(-20, -6, 40, 12); // 身
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(-16, -12, 32, 6); // 頂
      ctx.fillStyle = '#ff0000';
      ctx.fillRect(-4, 2, 8, 4); // 燈
      ctx.restore();
    }

    // 產生侵略者編隊
    function createInvaders() {
      invaders.length = 0;
      const rows = 5;
      const cols = 11;
      const invaderSize = 32;
      const padding = 8;
      const startX = (WIDTH - cols * invaderSize - (cols - 1) * padding) / 2;
      const startY = 50;

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const ix = startX + col * (invaderSize + padding);
          const iy = startY + row * (invaderSize + padding);
          invaders.push({
            x: ix,
            y: iy,
            width: invaderSize,
            height: invaderSize,
            type: Math.floor(row / 2), // 0:上兩排, 1:中兩排, 2:下排
            alive: true,
            points: row < 2 ? 30 : row < 4 ? 20 : 10 // 分數依位置
          });
        }
      }
    }

    // 更新遊戲邏輯
    function update() {
      if (gameState !== 'playing') return;
      frameCount++;

      // 玩家移動
      if (keys['ArrowLeft'] || keys['a'] || keys['A']) player.x -= player.speed;
      if (keys['ArrowRight'] || keys['d'] || keys['D']) player.x += player.speed;
      player.x = Math.max(0, Math.min(WIDTH - player.width, player.x));

      // 玩家射擊 (限速)
      if (keys[' '] && Date.now() - lastShootTime > SHOOT_COOLDOWN) {
        playerBullets.push({ x: player.x + player.width / 2, y: player.y });
        sounds.shoot();
        lastShootTime = Date.now();
      }

      // 子彈更新
      playerBullets.forEach((b, i) => {
        b.y -= PLAYER_BULLET_SPEED;
        if (b.y < 0) playerBullets.splice(i, 1);
      });
      enemyBullets.forEach((b, i) => {
        b.y += ENEMY_BULLET_SPEED;
        if (b.y > HEIGHT) enemyBullets.splice(i, 1);
      });

      // 侵略者群體移動
      if (frameCount % MOVE_FRAMES === 0) {
        let edgeHit = false;
        invaders.forEach(inv => {
          if (!inv.alive) return;
          inv.x += invaderSpeed * invaderMoveX;
          if (inv.x <= 0 || inv.x + inv.width >= WIDTH) edgeHit = true;
        });
        if (edgeHit) {
          invaderMoveX *= -1;
          invaders.forEach(inv => {
            if (inv.alive) inv.y += dropDistance;
          });
          // 觸底 gameover
          if (invaders.some(inv => inv.alive && inv.y > HEIGHT - 200)) {
            loseLife();
          }
        }
      }

      // 侵略者射擊 (隨機從存活者)
      if (frameCount % 60 === 0 && Math.random() < 0.3) {
        const aliveInvaders = invaders.filter(inv => inv.alive);
        if (aliveInvaders.length > 0) {
          const shooter = aliveInvaders[Math.floor(Math.random() * aliveInvaders.length)];
          enemyBullets.push({ x: shooter.x + shooter.width / 2, y: shooter.y + shooter.height });
        }
      }

      // UFO 出現 (每關隨機)
      ufoTimer++;
      if (ufoTimer > 1200 + Math.random() * 600 && !ufo) { // ~20秒一次
        ufo = { x: -50, y: 30, alive: true };
        sounds.ufo();
      }
      if (ufo) {
        ufo.x += 2;
        if (ufo.x > WIDTH + 50) {
          ufo = null;
          ufoTimer = 0;
        }
      }

      // 碰撞: 玩家子彈 vs 侵略者
      for (let i = playerBullets.length - 1; i >= 0; i--) {
        const pb = playerBullets[i];
        for (let j = invaders.length - 1; j >= 0; j--) {
          const inv = invaders[j];
          if (!inv.alive) continue;
          if (pb.x > inv.x && pb.x < inv.x + inv.width &&
              pb.y > inv.y && pb.y < inv.y + inv.height) {
            inv.alive = false;
            playerBullets.splice(i, 1);
            score += inv.points * level;
            scoreEl.textContent = score;
            if (score > highScore) {
              highScore = score;
              highscoreEl.textContent = highScore;
              localStorage.setItem('spaceInvadersHighScore', highScore);
            }
            sounds.invadeKill();
            break;
          }
        }
        // 玩家子彈 vs UFO
        if (ufo && pb.x > ufo.x && pb.x < ufo.x + 48 && pb.y > ufo.y && pb.y < ufo.y + 24) {
          playerBullets.splice(i, 1);
          score += 300;
          scoreEl.textContent = score;
          ufo = null;
          ufoTimer = 0;
          sounds.invadeKill();
        }
        // 玩家子彈 vs 屏障
        barriers.forEach(barrier => {
          for (let row = 0; row < BARRIER_ROWS; row++) {
            for (let col = 0; col < BARRIER_COLS; col++) {
              if (barrier.bricks[row][col]) {
                const bx = barrier.x + col * BRICK_WIDTH;
                const by = barrier.y + row * BRICK_HEIGHT;
                if (pb.x > bx && pb.x < bx + BRICK_WIDTH &&
                    pb.y > by && pb.y < by + BRICK_HEIGHT) {
                  barrier.bricks[row][col] = 0;
                  playerBullets.splice(i, 1);
                  sounds.barrierHit();
                  return;
                }
              }
            }
          }
        });
      }

      // 碰撞: 敵彈/侵略者 vs 玩家
      enemyBullets.forEach((eb, i) => {
        if (player.invincible > 0) return;
        if (eb.x > player.x && eb.x < player.x + player.width &&
            eb.y > player.y && eb.y < player.y + player.height) {
          enemyBullets.splice(i, 1);
          loseLife();
        }
        // 敵彈 vs 屏障
        barriers.forEach(barrier => {
          for (let row = 0; row < BARRIER_ROWS; row++) {
            for (let col = 0; col < BARRIER_COLS; col++) {
              if (barrier.bricks[row][col]) {
                const bx = barrier.x + col * BRICK_WIDTH;
                const by = barrier.y + row * BRICK_HEIGHT;
                if (eb.x > bx && eb.x < bx + BRICK_WIDTH &&
                    eb.y > by && eb.y < by + BRICK_HEIGHT) {
                  barrier.bricks[row][col] = 0;
                  enemyBullets.splice(i, 1);
                  sounds.barrierHit();
                  return;
                }
              }
            }
          }
        });
      });
      invaders.forEach(inv => {
        if (!inv.alive || player.invincible > 0) return;
        if (player.x < inv.x + inv.width && player.x + player.width > inv.x &&
            player.y < inv.y + inv.height && player.y + player.height > inv.y) {
          loseLife();
        }
      });

      // 全滅 → 下一關
      if (invaders.every(inv => !inv.alive)) {
        nextLevel();
      }

      // 無敵計時
      if (player.invincible > 0) player.invincible--;
    }

    function loseLife() {
      lives--;
      livesEl.textContent = lives;
      player.invincible = 120; // 2秒無敵
      player.x = WIDTH / 2 - 20;
      sounds.playerHit();
      if (lives <= 0) {
        gameOver();
      }
    }

    function nextLevel() {
      level++;
      levelEl.textContent = level;
      invaderSpeed += 0.2;
      dropDistance += 5;
      createInvaders();
      createBarriers();
      sounds.levelUp();
    }

    function gameOver() {
      gameState = 'gameover';
      message.textContent = 'GAME OVER\n點擊重新開始';
      message.style.display = 'block';
    }

    function startGame() {
      gameState = 'playing';
      score = 0;
      level = 1;
      lives = 3;
      scoreEl.textContent = score;
      levelEl.textContent = level;
      livesEl.textContent = lives;
      player.x = WIDTH / 2 - 20;
      player.y = HEIGHT - 80;
      playerBullets.length = 0;
      enemyBullets.length = 0;
      invaders.length = 0;
      barriers.length = 0;
      ufo = null;
      ufoTimer = 0;
      frameCount = 0;
      invaderMoveX = 1;
      invaderSpeed = 0.5;
      dropDistance = 20;
      message.style.display = 'none';
      createInvaders();
      createBarriers();
    }

    // 繪製一切
    function draw() {
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      // 邊框線
      ctx.strokeStyle = '#00ff00';
      ctx.lineWidth = 4;
      ctx.strokeRect(2, 2, WIDTH - 4, HEIGHT - 4);

      if (gameState === 'playing' || gameState === 'paused') {
        // 玩家
        drawPlayer(ctx, player.x, player.y, player.invincible > 0);

        // 玩家子彈
        playerBullets.forEach(b => drawBullet(ctx, b.x, b.y));

        // 敵人子彈
        enemyBullets.forEach(b => drawBullet(ctx, b.x, b.y, '#ff0000'));

        // 侵略者
        invaders.forEach(inv => {
          if (inv.alive) drawInvader(ctx, inv.x, inv.y, inv.type);
        });

        // 屏障
        barriers.forEach(b => drawBarrier(ctx, b));

        // UFO
        if (ufo) drawUFO(ctx, ufo.x, ufo.y);

        // 生命 (小船圖示)
        for (let i = 0; i < lives; i++) {
          drawPlayer(ctx, 20 + i * 50, HEIGHT - 40, false);
        }
      } else if (gameState === 'menu') {
        ctx.fillStyle = '#00ff00';
        ctx.font = 'bold 32px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('太空侵略者', WIDTH / 2, HEIGHT / 2 - 50);
        ctx.font = '20px Courier New';
        ctx.fillText('點擊開始遊戲', WIDTH / 2, HEIGHT / 2 + 20);
      } else if (gameState === 'gameover') {
        ctx.fillStyle = '#ff0000';
        ctx.font = 'bold 28px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(`最終分數: ${score}`, WIDTH / 2, HEIGHT / 2 + 50);
      }

      if (paused) {
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 48px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('PAUSED', WIDTH / 2, HEIGHT / 2);
      }
    }

    // 主遊戲循環
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // 事件監聽
    window.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.key === ' ') e.preventDefault();
      if (e.key.toLowerCase() === 'p' && gameState === 'playing') {
        paused = !paused;
      }
    });
    window.addEventListener('keyup', e => keys[e.key] = false);

    canvas.addEventListener('click', () => {
      if (gameState === 'menu' || gameState === 'gameover') {
        startGame();
      } else if (gameState === 'playing' || gameState === 'paused') {
        paused = !paused;
      }
    });

    // 初始化並啟動
    initAudio();
    gameState = 'menu';
    gameLoop();
  </script>
</body>
</html>
