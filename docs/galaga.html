<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>古早街機 - 小蜜蜂 進階版 (Galaga Pro)</title>
  <style>
    body {
      margin: 0;
      background: radial-gradient(circle, #000011, #000000);
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: 'Courier New', monospace;
      color: #00ff88;
      touch-action: none;
    }
    #game-container {
      position: relative;
    }
    canvas {
      image-rendering: pixelated;
      background: linear-gradient(to bottom, #000022, #000000);
      border: 4px solid #00ff88;
      box-shadow: 0 0 40px #00ff88;
      cursor: none;
    }
    #ui {
      position: absolute;
      top: 15px;
      left: 15px;
      font-size: 22px;
      text-shadow: 0 0 10px #00ff88;
      z-index: 10;
    }
    #high-score {
      position: absolute;
      top: 15px;
      right: 15px;
      font-size: 22px;
      color: #ffaa00;
      text-shadow: 0 0 10px #ffaa00;
    }
    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 52px;
      font-weight: bold;
      color: #ffff00;
      text-shadow: 0 0 30px #ff0000;
      pointer-events: none;
      display: none;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      50% { transform: translate(-50%, -50%) scale(1.05); opacity: 0.7; }
    }
    #instructions {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      color: #00ff88;
      text-align: center;
      text-shadow: 0 0 5px #00ff88;
    }
    #powerup {
      position: absolute;
      top: 80px;
      left: 15px;
      font-size: 18px;
      color: #ff44ff;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="ui">
      <div>分數: <span id="score">0</span></div>
      <div>關卡: <span id="level">1</span></div>
      <div>生命: <span id="lives">3</span></div>
    </div>
    <div id="high-score">最高分: <span id="highscore">0</span></div>
    <div id="powerup">雙機: OFF</div>
    <canvas id="canvas" width="400" height="600"></canvas>
    <div id="message">GAME OVER</div>
    <div id="instructions">
      ← → / A D 移動 | 空白 / 觸控射擊 | P 暫停 | 點擊重玩
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;

    // UI
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const livesEl = document.getElementById('lives');
    const highscoreEl = document.getElementById('highscore');
    const powerupEl = document.getElementById('powerup');
    const message = document.getElementById('message');

    // 遊戲狀態
    let gameState = 'menu'; // menu, playing, paused, gameover
    let score = 0;
    let highScore = localStorage.getItem('galagaHighScore') || 0;
    highscoreEl.textContent = highScore;
    let level = 1;
    let lives = 3;
    let keys = {};
    let touchX = WIDTH / 2;
    let lastShootTime = 0;
    const SHOOT_COOLDOWN = 120;
    let paused = false;
    let frameCount = 0;

    // 雙機模式
    let dualShip = false;
    let dualTimer = 0;
    const DUAL_DURATION = 18000; // 18秒

    // Audio
    let audioCtx;
    let bgMusic = null;
    function initAudio() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      // 背景音樂 (簡單loop)
      function playBGM() {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'sine';
        o.frequency.value = 110;
        g.gain.setValueAtTime(0.05, audioCtx.currentTime);
        o.connect(g);
        g.connect(audioCtx.destination);
        o.start();
        o.stop(audioCtx.currentTime + 0.5);
        bgMusic = setInterval(() => {
          if (gameState === 'playing') {
            const o2 = audioCtx.createOscillator();
            const g2 = audioCtx.createGain();
            o2.type = 'sine';
            o2.frequency.value = 110;
            g2.gain.setValueAtTime(0.03, audioCtx.currentTime);
            o2.connect(g2);
            g2.connect(audioCtx.destination);
            o2.start();
            o2.stop(audioCtx.currentTime + 0.5);
          }
        }, 500);
      }
      playBGM();
    }
    function playSound(freqs, duration, type = 'square', vol = 0.2) {
      if (!audioCtx) return;
      try {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type;
        o.frequency.setValueAtTime(freqs[0], audioCtx.currentTime);
        if (freqs.length > 1) o.frequency.linearRampToValueAtTime(freqs[1], audioCtx.currentTime + duration);
        g.gain.setValueAtTime(vol, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        o.connect(g);
        g.connect(audioCtx.destination);
        o.start(audioCtx.currentTime);
        o.stop(audioCtx.currentTime + duration);
      } catch(e) {}
    }
    const sounds = {
      shoot: () => playSound([880, 660], 0.08, 'sawtooth'),
      dualShoot: () => playSound([880, 1320], 0.1, 'sawtooth'),
      explodeSmall: () => playSound([440, 220], 0.15, 'sawtooth'),
      explodeBoss: () => playSound([220, 110, 55], 0.5, 'sawtooth'),
      capture: () => playSound([660, 880, 660], 0.3, 'sine'),
      levelUp: () => playSound([440, 554, 659, 880], 0.8, 'sine'),
      hurt: () => playSound([110, 55], 0.4, 'sawtooth'),
      bossAppear: () => playSound([77, 110, 154], 1.2, 'triangle')
    };

    // 玩家
    const player = {
      x: WIDTH / 2 - 15,
      y: HEIGHT - 60,
      width: 30,
      height: 25,
      speed: 7,
      invincible: 0
    };

    // 子彈
    const playerBullets = [];
    const BULLET_SPEED = 11;
    const enemyBullets = [];
    const ENEMY_BULLET_SPEED = 5;

    // 敵人
    const enemies = [];
    let enemyDirection = 1;
    let enemySpeed = 0.8;
    let diveAttackers = []; // 俯衝敵人

    // 粒子效果
    const particles = [];

    // Boss
    let boss = null;
    const BOSS_SIZE = 80;

    // 星星背景
    const stars = [];
    for (let i = 0; i < 100; i++) {
      stars.push({ x: Math.random() * WIDTH, y: Math.random() * HEIGHT, speed: 0.3 + Math.random() * 2, size: 0.5 + Math.random() * 1.5 });
    }

    // Sprite 繪製 (進階細節)
    function drawPlayer(ctx, x, y, dual = false, invincible = false) {
      if (invincible > 0 && Math.floor(frameCount / 4) % 2 === 0) return;
      ctx.save();
      ctx.translate(x + 15, y + 12);
      ctx.scale(1.1, 1.2);

      // 主船身
      ctx.fillStyle = '#00ff88';
      ctx.beginPath();
      ctx.moveTo(0, -15);
      ctx.lineTo(-13, 10);
      ctx.lineTo(-7, 14);
      ctx.lineTo(0, 12);
      ctx.lineTo(7, 14);
      ctx.lineTo(13, 10);
      ctx.closePath();
      ctx.fill();

      // 翼
      ctx.fillStyle = '#008844';
      ctx.beginPath();
      ctx.moveTo(-11, 1);
      ctx.lineTo(-20, 8);
      ctx.lineTo(-14, 8);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(11, 1);
      ctx.lineTo(20, 8);
      ctx.lineTo(14, 8);
      ctx.closePath();
      ctx.fill();

      // 引擎
      ctx.fillStyle = '#ffff44';
      ctx.fillRect(-3, 12, 6, 8);
      ctx.fillStyle = '#ffaa00';
      ctx.fillRect(-1.5, 15, 3, 5);

      // 雙機 (左/右)
      if (dual) {
        ctx.save();
        ctx.translate(-12, 0);
        ctx.scale(0.7, 0.7);
        ctx.fillStyle = '#00cc66';
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(-8, 6);
        ctx.lineTo(-4, 9);
        ctx.lineTo(0, 7);
        ctx.lineTo(4, 9);
        ctx.lineTo(8, 6);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
        ctx.save();
        ctx.translate(12, 0);
        ctx.scale(0.7, 0.7);
        ctx.fillStyle = '#00cc66';
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(-8, 6);
        ctx.lineTo(-4, 9);
        ctx.lineTo(0, 7);
        ctx.lineTo(4, 9);
        ctx.lineTo(8, 6);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      ctx.restore();
    }

    function drawEnemy(ctx, x, y, type, scale = 1, diving = false) {
      ctx.save();
      ctx.translate(x + 14, y + 11);
      ctx.scale(scale, scale);

      let bodyColor, wingColor;
      switch(type) {
        case 0: // 旗艦 (紅，大)
          bodyColor = '#ff4444'; wingColor = '#aa0000';
          break;
        case 1: // 中蜂 (橙)
          bodyColor = '#ff8844'; wingColor = '#cc5500';
          break;
        case 2: // 小蜂 (黃)
          bodyColor = '#ffff44'; wingColor = '#aaaa00';
          break;
        case 3: // 綠兵 (捕獲用)
          bodyColor = '#44ff44'; wingColor = '#00aa00';
          break;
      }

      // 身體 (蜂形)
      ctx.fillStyle = bodyColor;
      ctx.beginPath();
      ctx.ellipse(0, -3, 12, 9, 0, 0, Math.PI * 2);
      ctx.fill();

      // 翼/爪
      ctx.fillStyle = wingColor;
      ctx.beginPath();
      ctx.moveTo(-9, 1);
      ctx.lineTo(-16, 7);
      ctx.lineTo(-7, 7);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(9, 1);
      ctx.lineTo(16, 7);
      ctx.lineTo(7, 7);
      ctx.closePath();
      ctx.fill();

      // 眼睛 (閃爍)
      ctx.fillStyle = diving ? '#ffff00' : '#000';
      ctx.beginPath();
      ctx.arc(-4, -5, 2.5, 0, Math.PI * 2);
      ctx.arc(4, -5, 2.5, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function drawBoss(ctx, x, y) {
      ctx.save();
      ctx.translate(x + 40, y + 30);
      ctx.scale(1.3, 1.3);

      // Boss身體 (多段)
      ctx.fillStyle = '#ff0000';
      ctx.fillRect(-30, -20, 80, 40);
      ctx.fillStyle = '#cc0000';
      ctx.beginPath();
      ctx.arc(0, -25, 25, 0, Math.PI * 2);
      ctx.fill();

      // 炮台 (左右)
      ctx.fillStyle = '#ff4444';
      ctx.fillRect(-35, -10, 20, 20);
      ctx.fillRect(15, -10, 20, 20);

      // 眼睛
      ctx.fillStyle = '#ffff00';
      ctx.beginPath();
      ctx.arc(-10, -5, 6, 0, Math.PI * 2);
      ctx.arc(10, -5, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(-8, -4, 3, 0, Math.PI * 2);
      ctx.arc(8, -4, 3, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function drawBullet(ctx, x, y, color = '#ffff88', size = 1) {
      ctx.fillStyle = color;
      ctx.fillRect(x - 2 * size, y - 8 * size, 4 * size, 16 * size);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(x - size, y - 4 * size, 2 * size, 8 * size);
    }

    function createParticles(x, y, color = '#ffff44', count = 12) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 8,
          vy: (Math.random() - 0.5) * 8,
          life: 30 + Math.random() * 20,
          color,
          size: 2 + Math.random() * 3
        });
      }
    }

    // 產生編隊 (進階: 依關卡變化)
    function createFormation() {
      enemies.length = 0;
      const rows = 5 + Math.floor(level / 3);
      const cols = 8 + Math.floor(level / 5);
      const eWidth = 28;
      const eHeight = 22;
      const padding = 14;
      const offsetTop = 30;
      const offsetLeft = (WIDTH - cols * eWidth - (cols-1)*padding) / 2;

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const ex = offsetLeft + col * (eWidth + padding);
          const ey = offsetTop + row * (eHeight + padding);
          const type = row === 0 ? 0 : row === 1 ? 1 : Math.random() < 0.3 ? 3 : 2; // 綠兵機率增
          enemies.push({
            x: ex, y: ey,
            width: eWidth, height: eHeight,
            alive: true,
            type,
            phase: 'formation', // formation, diving
            diveY: 0,
            shootTimer: 0
          });
        }
      }
      enemySpeed = 0.7 + level * 0.12;
    }

    // Boss產生 (每5關)
    function spawnBoss() {
      boss = {
        x: WIDTH / 2 - 40,
        y: 20,
        width: BOSS_SIZE,
        height: 60,
        hp: 10 + level * 2,
        phase: 'enter', // enter, attack, die
        shootTimer: 0,
        diveTimer: 0
      };
      sounds.bossAppear();
    }

    // 更新
    function update() {
      if (gameState !== 'playing') return;
      frameCount++;

      // 玩家移動
      if ((keys['ArrowLeft'] || keys['a'] || keys['A']) && player.x > 0) player.x -= player.speed;
      if ((keys['ArrowRight'] || keys['d'] || keys['D']) && player.x < WIDTH - player.width) player.x += player.speed;
      player.x = Math.max(0, Math.min(WIDTH - player.width, player.x));

      // 觸控移動
      player.x = Math.max(0, Math.min(WIDTH - player.width, touchX - player.width / 2));

      // 射擊 (雙機雙彈)
      if (keys[' '] || (gameState === 'playing' && touchActive)) {
        if (Date.now() - lastShootTime > SHOOT_COOLDOWN) {
          const offset = dualShip ? 8 : 0;
          playerBullets.push({ x: player.x + player.width / 2 - offset, y: player.y, heavy: false });
          if (dualShip) playerBullets.push({ x: player.x + player.width / 2 + offset, y: player.y, heavy: false });
          dualShip ? sounds.dualShoot() : sounds.shoot();
          lastShootTime = Date.now();
        }
      }

      // 子彈更新
      playerBullets.forEach((b, i) => {
        b.y -= BULLET_SPEED;
        if (b.y < -20) playerBullets.splice(i, 1);
      });
      enemyBullets.forEach((b, i) => {
        b.y += ENEMY_BULLET_SPEED + Math.sin(frameCount * 0.1) * 0.5; // 蛇行
        if (b.y > HEIGHT) enemyBullets.splice(i, 1);
      });

      // 星星
      stars.forEach(s => {
        s.y += s.speed;
        if (s.y > HEIGHT) s.y = -s.size;
      });

      // 粒子
      particles.forEach((p, i) => {
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        p.vx *= 0.95;
        p.vy *= 0.95;
        if (p.life <= 0) particles.splice(i, 1);
      });

      // 雙機計時
      if (dualShip && dualTimer > 0) {
        dualTimer--;
        if (dualTimer <= 0) {
          dualShip = false;
          powerupEl.textContent = '雙機: OFF';
        }
      }

      // 編隊移動
      let edgeHit = false;
      enemies.forEach(e => {
        if (!e.alive || e.phase === 'diving') return;
        e.x += enemySpeed * enemyDirection;
        if (e.x <= 10 || e.x + e.width >= WIDTH - 10) edgeHit = true;
      });
      if (edgeHit) {
        enemyDirection *= -1;
        enemies.forEach(e => {
          if (e.alive && e.phase === 'formation') e.y += 25;
        });
        if (enemies.some(e => e.alive && e.phase === 'formation' && e.y > HEIGHT - 150)) loseLife();
      }

      // 俯衝攻擊 (隨機選敵)
      if (frameCount % 90 === 0 && enemies.length > 10) {
        const candidates = enemies.filter(e => e.alive && e.phase === 'formation' && e.type >= 1);
        if (candidates.length > 0) {
          const diver = candidates[Math.floor(Math.random() * candidates.length)];
          diver.phase = 'diving';
          diver.diveTargetX = player.x + player.width / 2;
          diver.diveSpeed = 0.3 + Math.random() * 0.4;
          diveAttackers.push(diver);
        }
      }

      // 更新俯衝
      diveAttackers.forEach((d, i) => {
        d.x += (d.diveTargetX - d.x) * d.diveSpeed;
        d.y += 4 + d.type * 0.5;
        if (d.y > HEIGHT + 50) {
          diveAttackers.splice(i, 1);
          d.phase = 'formation';
          d.y = 50; // 重置
        }
      });

      // 敵人射擊
      enemies.forEach(e => {
        if (!e.alive) return;
        e.shootTimer++;
        if (e.shootTimer > 60 + e.type * 20 && Math.random() < 0.02 + level * 0.001) {
          enemyBullets.push({ x: e.x + e.width / 2, y: e.y + e.height, color: '#ff4400' });
          e.shootTimer = 0;
        }
      });

      // Boss邏輯
      if (boss) {
        if (boss.phase === 'enter') {
          boss.y += 1;
          if (boss.y > 80) boss.phase = 'attack';
        } else if (boss.phase === 'attack') {
          boss.shootTimer++;
          if (boss.shootTimer > 45) {
            enemyBullets.push({ x: boss.x + 15, y: boss.y + boss.height, color: '#ff0000', speed: 6 });
            enemyBullets.push({ x: boss.x + boss.width - 15, y: boss.y + boss.height, color: '#ff0000', speed: 6 });
            boss.shootTimer = 0;
          }
          boss.diveTimer++;
          if (boss.diveTimer > 300 && boss.y < HEIGHT - 200) { // 偶爾俯衝
            boss.y += 3;
          } else if (boss.diveTimer > 360) {
            boss.diveTimer = 0;
          }
        }
        if (boss.hp <= 0) {
          boss.phase = 'die';
          createParticles(boss.x + BOSS_SIZE/2, boss.y + 30, '#ff4444', 50);
          sounds.explodeBoss();
          score += 5000 * level;
          boss = null;
        }
      } else if (level % 5 === 0 && enemies.every(e => !e.alive)) {
        spawnBoss();
      }

      // 碰撞
      // 玩家彈 vs 敵人
      for (let i = playerBullets.length - 1; i >= 0; i--) {
        const pb = playerBullets[i];
        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          if (!e.alive) continue;
          if (pb.x > e.x && pb.x < e.x + e.width && pb.y > e.y && pb.y < e.y + e.height) {
            e.alive = false;
            playerBullets.splice(i, 1);
            score += (20 + e.type * 40) * level;
            createParticles(e.x + e.width/2, e.y + e.height/2);
            sounds.explodeSmall();
            // 捕獲綠兵 → 雙機
            if (e.type === 3 && !dualShip && Math.random() < 0.4) {
              dualShip = true;
              dualTimer = DUAL_DURATION;
              powerupEl.textContent = '雙機: ON';
              sounds.capture();
            }
            break;
          }
        }
        // vs Boss
        if (boss && pb.x > boss.x && pb.x < boss.x + boss.width && pb.y > boss.y && pb.y < boss.y + boss.height) {
          boss.hp--;
          playerBullets.splice(i, 1);
          createParticles(pb.x, pb.y, '#ffaa44');
        }
      }

      // 敵彈/敵人/俯衝 vs 玩家
      if (player.invincible === 0) {
        enemyBullets.forEach((eb, i) => {
          if (eb.x > player.x && eb.x < player.x + player.width && eb.y > player.y && eb.y < player.y + player.height) {
            enemyBullets.splice(i, 1);
            loseLife();
          }
        });
        enemies.forEach(e => {
          if (!e.alive) return;
          if (player.x < e.x + e.width && player.x + player.width > e.x &&
              player.y < e.y + e.height && player.y + player.height > e.y) {
            loseLife();
          }
        });
        diveAttackers.forEach(d => {
          if (player.x < d.x + d.width && player.x + player.width > d.x &&
              player.y < d.y + d.height && player.y + player.height > d.y) {
            loseLife();
          }
        });
        if (boss && player.x < boss.x + boss.width && player.x + player.width > boss.x &&
            player.y < boss.y + boss.height && player.y + player.height > boss.y) {
          loseLife();
        }
      }

      // 勝利條件
      const aliveEnemies = enemies.filter(e => e.alive && e.phase === 'formation').length;
      if (aliveEnemies === 0 && !boss) {
        nextLevel();
      }

      if (player.invincible > 0) player.invincible--;
    }

    function loseLife() {
      lives--;
      livesEl.textContent = lives;
      player.invincible = 180; // 3秒無敵
      sounds.hurt();
      if (lives <= 0) {
        if (score > highScore) {
          highScore = score;
          highscoreEl.textContent = highScore;
          localStorage.setItem('galagaHighScore', highScore);
        }
        gameOver();
      }
    }

    function nextLevel() {
      level++;
      levelEl.textContent = level;
      score += 2000 * level;
      scoreEl.textContent = score;
      sounds.levelUp();
      setTimeout(() => {
        createFormation();
      }, 3000);
      message.textContent = `關卡 ${level} !`;
      message.style.color = '#00ff88';
      message.style.display = 'block';
      setTimeout(() => message.style.display = 'none', 2000);
    }

    function gameOver() {
      gameState = 'gameover';
      message.textContent = 'GAME OVER\n點擊重玩';
      message.style.color = '#ff4444';
      message.style.display = 'block';
      clearInterval(bgMusic);
    }

    function startGame() {
      gameState = 'playing';
      score = 0;
      level = 1;
      lives = 3;
      dualShip = false;
      dualTimer = 0;
      scoreEl.textContent = score;
      levelEl.textContent = level;
      livesEl.textContent = lives;
      powerupEl.textContent = '雙機: OFF';
      player.x = WIDTH / 2 - 15;
      player.y = HEIGHT - 60;
      playerBullets.length = 0;
      enemyBullets.length = 0;
      enemies.length = 0;
      diveAttackers.length = 0;
      particles.length = 0;
      boss = null;
      enemyDirection = 1;
      frameCount = 0;
      message.style.display = 'none';
      createFormation();
    }

    // 繪製
    function draw() {
      ctx.fillStyle = '#000011';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      // 星星
      ctx.fillStyle = '#aaccff';
      stars.forEach(s => ctx.fillRect(s.x, s.y, s.size, s.size));

      // 粒子
      particles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.life / 50;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size, p.size);
        ctx.restore();
      });

      if (gameState === 'playing' || gameState === 'paused') {
        // 玩家
        drawPlayer(ctx, player.x, player.y, dualShip, player.invincible > 0);

        // 子彈
        playerBullets.forEach(b => drawBullet(ctx, b.x, b.y));
        enemyBullets.forEach(b => drawBullet(ctx, b.x, b.y, b.color || '#ff6600'));

        // 敵人編隊
        enemies.forEach(e => {
          if (e.alive) {
            const diving = diveAttackers.includes(e);
            drawEnemy(ctx, e.x, e.y, e.type, 1, diving);
          }
        });

        // 俯衝軌跡 (視覺)
        ctx.strokeStyle = '#ff4444';
        ctx.lineWidth = 2;
        ctx.beginPath();
        diveAttackers.forEach(d => {
          ctx.moveTo(d.x + d.width/2, d.y);
          ctx.lineTo(d.x + d.width/2, HEIGHT);
        });
        ctx.stroke();

        // Boss
        if (boss) drawBoss(ctx, boss.x, boss.y);

        // 生命
        for (let i = 0; i < lives; i++) {
          drawPlayer(ctx, 15 + i * 40, 15, false);
        }

        // Boss HP
        if (boss) {
          ctx.fillStyle = '#000';
          ctx.fillRect(10, HEIGHT - 30, 100, 15);
          ctx.fillStyle = '#ff0000';
          ctx.fillRect(10, HEIGHT - 30, (boss.hp / (10 + level * 2)) * 100, 15);
        }
      } else if (gameState === 'menu') {
        ctx.fillStyle = '#00ff88';
        ctx.font = 'bold 36px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('小蜜蜂 進階版', WIDTH / 2, HEIGHT / 2 - 40);
        ctx.font = '24px Courier New';
        ctx.fillText('點擊 / 觸控 開始', WIDTH / 2, HEIGHT / 2 + 30);
      }

      if (paused) {
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 52px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('PAUSED', WIDTH / 2, HEIGHT / 2);
      }
    }

    // 主循環
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // 事件
    let touchActive = false;
    window.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.key === ' ') e.preventDefault();
      if (e.key.toLowerCase() === 'p' && gameState === 'playing') paused = !paused;
    });
    window.addEventListener('keyup', e => keys[e.key] = false);

    canvas.addEventListener('click', () => {
      if (gameState === 'menu' || gameState === 'gameover') startGame();
      else if (gameState === 'playing') paused = !paused;
    });

    // 觸控
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      touchActive = true;
    });
    canvas.addEventListener('touchend', () => touchActive = false);
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      touchX = (touch.clientX - rect.left) * (WIDTH / rect.width);
    });

    // 啟動
    initAudio();
    gameState = 'menu';
    gameLoop();
  </script>
</body>
</html>
