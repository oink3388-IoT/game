<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>古早街機 - 小蜜蜂 (加強版)</title>
  <style>
    body {
      margin: 0;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: 'Courier New', monospace;
      color: #0f0;
    }
    #game-container {
      position: relative;
    }
    canvas {
      image-rendering: pixelated;
      background: linear-gradient(to bottom, #001122, #000011);
      border: 3px solid #0f0;
      box-shadow: 0 0 20px #0f0;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 20px;
      text-shadow: 0 0 5px #0f0;
    }
    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: #ff0;
      text-shadow: 0 0 20px #f00;
      pointer-events: none;
      display: none;
      animation: blink 1s infinite;
    }
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }
    #instructions {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 14px;
      color: #0f0;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="ui">
      <div>分數: <span id="score">0</span></div>
      <div>關卡: <span id="level">1</span></div>
      <div>生命: <span id="lives">3</span></div>
    </div>
    <canvas id="canvas" width="400" height="600"></canvas>
    <div id="message">GAME OVER</div>
    <div id="instructions">
      ← → 或 A D 移動 | 空白鍵射擊 | 點擊重新開始
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;

    // UI
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const livesEl = document.getElementById('lives');
    const message = document.getElementById('message');

    // 遊戲狀態
    let gameState = 'playing'; // playing, gameover, nextlevel
    let score = 0;
    let level = 1;
    let lives = 3;
    let keys = {};
    let lastShootTime = 0;
    const shootCooldown = 150; // ms 防止連發

    // Audio Context for sounds
    let audioCtx;
    function initAudio() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    function playTone(freq, duration, type = 'square') {
      if (!audioCtx) return;
      try {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type;
        o.frequency.value = freq;
        g.gain.setValueAtTime(0.2, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        o.connect(g);
        g.connect(audioCtx.destination);
        o.start(audioCtx.currentTime);
        o.stop(audioCtx.currentTime + duration);
      } catch(e) {}
    }
    const sounds = {
      shoot: () => playTone(880, 0.08, 'sawtooth'),
      explode: () => playTone(220, 0.15, 'sawtooth'),
      levelup: () => playTone(440, 0.3, 'sine'),
      hurt: () => playTone(110, 0.4, 'sawtooth')
    };

    // 玩家
    const player = {
      x: WIDTH / 2 - 15,
      y: HEIGHT - 50,
      width: 30,
      height: 25,
      speed: 6
    };

    // 子彈
    const playerBullets = [];
    const BULLET_SPEED = 10;

    // 敵人子彈
    const enemyBullets = [];
    const ENEMY_BULLET_SPEED = 4;

    // 敵人
    const enemies = [];
    let enemyMoveX = 1;
    let enemyMoveY = 0;
    let enemySpeed = 0.6;
    let dropTimer = 0;
    const DROP_INTERVAL = 120; // frames

    // 星星背景
    const stars = [];
    for (let i = 0; i < 80; i++) {
      stars.push({
        x: Math.random() * WIDTH,
        y: Math.random() * HEIGHT,
        speed: 0.5 + Math.random() * 1.5,
        size: 1 + Math.random() * 1
      });
    }

    // 繪製 Sprite 函數 (取代 fillRect，更像原版)
    function drawPlayer(ctx, x, y) {
      ctx.save();
      ctx.translate(x + 15, y + 12);
      ctx.scale(1, 1.2);

      // 船身
      ctx.fillStyle = '#00ff88';
      ctx.beginPath();
      ctx.moveTo(0, -12);
      ctx.lineTo(-12, 8);
      ctx.lineTo(-6, 12);
      ctx.lineTo(0, 10);
      ctx.lineTo(6, 12);
      ctx.lineTo(12, 8);
      ctx.closePath();
      ctx.fill();

      // 翼
      ctx.fillStyle = '#008844';
      ctx.beginPath();
      ctx.moveTo(-10, 0);
      ctx.lineTo(-18, 6);
      ctx.lineTo(-12, 6);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(10, 0);
      ctx.lineTo(18, 6);
      ctx.lineTo(12, 6);
      ctx.closePath();
      ctx.fill();

      // 引擎光
      ctx.fillStyle = '#ffff00';
      ctx.fillRect(-2, 10, 4, 6);
      ctx.fillStyle = '#ffaa00';
      ctx.fillRect(-1, 12, 2, 4);

      ctx.restore();
    }

    function drawEnemy(ctx, x, y, type) {
      ctx.save();
      ctx.translate(x + 15, y + 12);

      let color1, color2, shapeScale = 1;
      switch(type) {
        case 0: // 旗艦 (紅色，大)
          color1 = '#ff4444'; color2 = '#aa0000'; shapeScale = 1.2;
          break;
        case 1: // 蜂 (橙色)
          color1 = '#ff8844'; color2 = '#cc6600';
          break;
        default: // 小兵 (黃/綠)
          color1 = type % 2 ? '#ffff44' : '#44ff44';
          color2 = type % 2 ? '#aaaa00' : '#00aa00';
      }

      ctx.scale(shapeScale, shapeScale);

      // 身體
      ctx.fillStyle = color1;
      ctx.beginPath();
      ctx.arc(0, -4, 10, 0, Math.PI * 2);
      ctx.fill();

      // 翼/腳
      ctx.fillStyle = color2;
      ctx.beginPath();
      ctx.moveTo(-8, 2);
      ctx.lineTo(-14, 8);
      ctx.lineTo(-6, 8);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(8, 2);
      ctx.lineTo(14, 8);
      ctx.lineTo(6, 8);
      ctx.closePath();
      ctx.fill();

      // 眼睛
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(-4, -6, 2, 0, Math.PI * 2);
      ctx.arc(4, -6, 2, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function drawBullet(ctx, x, y, color = '#ffff00') {
      ctx.fillStyle = color;
      ctx.fillRect(x - 2, y - 6, 4, 12);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(x - 1, y - 4, 2, 4);
    }

    // 產生敵人編隊 (依關卡變化)
    function createEnemies() {
      enemies.length = 0;
      const rows = 4 + (level % 3); // 4-6 行
      const cols = 8 + Math.floor(level / 3); // 漸增
      const enemyWidth = 28;
      const enemyHeight = 22;
      const padding = 12 + (level > 5 ? 2 : 0);
      const offsetTop = 30 + Math.sin(level) * 10; // 小變化
      const offsetLeft = (WIDTH - cols * enemyWidth - (cols - 1) * padding) / 2;

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const ex = col * (enemyWidth + padding) + offsetLeft;
          const ey = row * (enemyHeight + padding) + offsetTop;
          enemies.push({
            x: ex,
            y: ey,
            width: enemyWidth,
            height: enemyHeight,
            alive: true,
            type: Math.min(row, 4), // 0=旗艦, 1=蜂, 2+=小兵
            lastShoot: 0
          });
        }
      }
      enemySpeed = 0.6 + level * 0.15;
    }

    // 更新遊戲
    function update() {
      if (gameState !== 'playing') return;

      // 玩家移動
      if ((keys['ArrowLeft'] || keys['a'] || keys['A'])) player.x -= player.speed;
      if ((keys['ArrowRight'] || keys['d'] || keys['D'])) player.x += player.speed;
      player.x = Math.max(0, Math.min(WIDTH - player.width, player.x));

      // 玩家射擊 (限速)
      if (keys[' '] && Date.now() - lastShootTime > shootCooldown) {
        playerBullets.push({
          x: player.x + player.width / 2,
          y: player.y
        });
        sounds.shoot();
        lastShootTime = Date.now();
      }

      // 子彈更新
      playerBullets.forEach((b, i) => {
        b.y -= BULLET_SPEED;
        if (b.y < -20) playerBullets.splice(i, 1);
      });
      enemyBullets.forEach((b, i) => {
        b.y += ENEMY_BULLET_SPEED;
        if (b.y > HEIGHT + 20) enemyBullets.splice(i, 1);
      });

      // 星星滾動
      stars.forEach(s => {
        s.y += s.speed;
        if (s.y > HEIGHT) s.y = 0;
      });

      // 敵人群體移動
      dropTimer++;
      let hitEdge = false;
      enemies.forEach(e => {
        if (!e.alive) return;
        e.x += enemySpeed * enemyMoveX;
        if (e.x <= 5 || e.x + e.width >= WIDTH - 5) hitEdge = true;
      });

      if (hitEdge && dropTimer > DROP_INTERVAL) {
        enemyMoveX *= -1;
        enemies.forEach(e => { if (e.alive) e.y += 25; });
        dropTimer = 0;
        // 掉太低 gameover
        if (enemies.some(e => e.alive && e.y > HEIGHT - 150)) {
          loseLife();
        }
      }

      // 敵人個體射擊 (後排多)
      enemies.forEach(e => {
        if (!e.alive || Date.now() - e.lastShoot < 800 + e.type * 200) return;
        if (Math.random() < 0.015 + level * 0.002) {
          enemyBullets.push({
            x: e.x + e.width / 2,
            y: e.y + e.height,
            color: '#ff4400'
          });
          e.lastShoot = Date.now();
        }
      });

      // 碰撞: 玩家子彈 vs 敵人
      for (let i = playerBullets.length - 1; i >= 0; i--) {
        const pb = playerBullets[i];
        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          if (!e.alive) continue;
          if (pb.x > e.x && pb.x < e.x + e.width &&
              pb.y > e.y && pb.y < e.y + e.height) {
            e.alive = false;
            playerBullets.splice(i, 1);
            score += 20 + e.type * 30 + level * 10;
            scoreEl.textContent = score;
            sounds.explode();
            break;
          }
        }
      }

      // 碰撞: 玩家 vs 敵人/敵彈
      enemies.forEach(e => {
        if (!e.alive || gameState !== 'playing') return;
        if (player.x < e.x + e.width && player.x + player.width > e.x &&
            player.y < e.y + e.height && player.y + player.height > e.y) {
          loseLife();
        }
      });
      enemyBullets.forEach((eb, i) => {
        if (player.x < eb.x + 4 && player.x + player.width > eb.x - 4 &&
            player.y < eb.y + 12 && player.y + player.height > eb.y) {
          enemyBullets.splice(i, 1);
          loseLife();
        }
      });

      // 勝利: 全滅 → 下一關
      if (enemies.every(e => !e.alive)) {
        nextLevel();
      }
    }

    function loseLife() {
      lives--;
      livesEl.textContent = lives;
      sounds.hurt();
      if (lives <= 0) {
        gameOver();
      } else {
        // 短暫無敵 (可加閃爍)
        player.y = HEIGHT - 50;
        player.x = WIDTH / 2 - 15;
      }
    }

    function nextLevel() {
      gameState = 'nextlevel';
      score += 1000 * level;
      scoreEl.textContent = score;
      sounds.levelup();
      setTimeout(() => {
        level++;
        levelEl.textContent = level;
        enemySpeed = 0.6 + level * 0.15;
        createEnemies();
        gameState = 'playing';
      }, 2000);
      message.textContent = `關卡 ${level} 清關!`;
      message.style.color = '#00ff88';
      message.style.display = 'block';
      setTimeout(() => message.style.display = 'none', 2000);
    }

    function gameOver() {
      gameState = 'gameover';
      message.textContent = 'GAME OVER';
      message.style.color = '#ff4444';
      message.style.display = 'block';
    }

    // 繪製
    function draw() {
      // 清屏
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      // 星星
      ctx.fillStyle = '#aaccff';
      stars.forEach(s => {
        ctx.fillRect(s.x, s.y, s.size, s.size);
      });

      // 玩家
      drawPlayer(ctx, player.x, player.y);

      // 玩家子彈
      playerBullets.forEach(b => drawBullet(ctx, b.x, b.y));

      // 敵人子彈
      enemyBullets.forEach(b => drawBullet(ctx, b.x, b.y, '#ff6600'));

      // 敵人
      enemies.forEach(e => {
        if (e.alive) drawEnemy(ctx, e.x, e.y, e.type);
      });

      // 生命顯示 (小船)
      for (let i = 0; i < lives; i++) {
        drawPlayer(ctx, 10 + i * 35, 10);
      }
    }

    // 主循環
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // 事件
    window.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.key === ' ') e.preventDefault();
    });
    window.addEventListener('keyup', e => keys[e.key] = false);

    canvas.addEventListener('click', () => {
      if (gameState !== 'playing') {
        resetGame();
      }
    });

    function resetGame() {
      score = 0;
      level = 1;
      lives = 3;
      gameState = 'playing';
      player.x = WIDTH / 2 - 15;
      player.y = HEIGHT - 50;
      playerBullets.length = 0;
      enemyBullets.length = 0;
      enemies.length = 0;
      enemyMoveX = 1;
      dropTimer = 0;
      scoreEl.textContent = score;
      levelEl.textContent = level;
      livesEl.textContent = lives;
      message.style.display = 'none';
      createEnemies();
    }

    // 啟動
    initAudio();
    resetGame();
    gameLoop();
  </script>
</body>
</html>
